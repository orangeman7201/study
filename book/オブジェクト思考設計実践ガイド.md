# 8章 コンポジションでオブジェクトを組み合わせる

## 8.3 Partsを製造する
### 読む前の仮説
多分この章はPartを組み合わせてPartsを作ろう、その方法はこんな感じか？
1. Partを定義する
2. Partを継承したclsssを定義する
3. Partsを継承したBycicleを定義する


### 書いてたこと
#### ファクトリーという概念
* 責務
1. 以下のような配列をとってPartsオブジェクトを製造すること
``` config 
[['part1', 'function1'], ['part2', 'function2']]
```
2. config配列の順番と機能に関する知識

* メリット
1. ファクトリを使うことで有効なPartsを作るために必要な知識を分離することができる。以前はPartsクラスが知っていたがこれでFactoryに分離できるようになった。
2. PartクラスがなくなってPartsFactoryClassで表現することで、initializeで登場していたfetchとかの若干難しいところすらも簡単に置き換えることができる
  * 正直どっちの方がいいかと言われれば、学習コスト的にinitializeというわかりやすいところで書かれているPartクラスの方が読みやすそう。

### わからなかったところ
* ファクトリーは必要か？
  * そこまで分けて何のメリットがあるのか
* OpenStructクラスとは？
  * データ構造でHashみたいなもの
  * attributesを定義できて、それらに対してvalueを渡せる
* PartをOpenStructで定義できたらなんか嬉しいのか？


## 8.4 コンポーズされたBicycle
### 読む前の仮説
さっき置き換えたPartクラスをPartFactoryで置き換えるパートかな

### 書いてたこと
* 概ね仮説通り
  * 若干違うなと思った点
    * Obstractで作ったPartFactoryで作ったクラスの方が見やすいかも
    * 新しい自転車の種類を作るときにconfigに設定を書けば、それをFactoryに渡すだけで新しい種類の自転車が作れる

### わからなかったところ
特になし

## 8.5 コンポジションと継承の選択
### 読む前の仮説
* 8.3で書いたOpenStructを選択せずに単純にPartクラスのままでもいいっちゃいいよ
  * チームの力量やったり、Partに当たるものが頻繁に増えない場合は継承の方がメンテナンスするときに見る場所が減って楽
  * CMSを使うかハードコードするか見たいな感じ

### 書いてたこと
* 継承
  * メリット
    * 見通しがよく、合理的で利用性が高いこと
  * デメリット
    * ちゃんと使わないと依存関係ががんじがらめになること
    * 継承が適さないときに継承を使っちゃうと変更しにくい構造になること
      * サブクラスに書くかスーパークラスに書くか問題
      * スーパークラスの影響範囲がめちゃくちゃデカくなるのでリファクタしずらい
  * 名言
    * 継承を選択するときは過去のコードが多く使いつつ、新しいコードの追加が比較的少量の時に既存のクラスに機能を追加するとき
* コンポジション
  * メリット
    * ファクトリで作ったObject同士が互いに独立していること
  * デメリット
    * 移譲のコストがかかること
    * 全体の姿が見えにくいこと
  * 名言
    * 振る舞いがそれを構成するパーツのそうわを上回る時

### わからなかったところ
* 振る舞いがそれを構成するパーツのそうわを上回る時
  * 振る舞いが上回るとは？


# 9章 費用対効果の高いテストを設計する
## 9.0
### 読む前の仮説
* 費用対効果が高いとは？
  * 過不足がないテストであること
  * 小さいコンポーネントを作ることで小さく検証できる
* テスト設計がなぜ大切か？
  * テスト設計があるとそもそもコードを小さくできる


### 書いてたこと
* なぜ価値の高いテストを書く能力が求められるのか
  * 絶えずリファクタをする中で、価値の高いテストがあれば安心してリファクタできるし、テストコードも書き直す必要がないから

### わからなかったところ
なし

## 9.1 意図を持ったテスト
### 読む前の仮説
* 意図を持っているとは
  * 漫然と頭からテストを書かないこと
  * リファクタを前提にinputとoutputだけを検証すること
  * 中身を変更してもテストコードを変更する必要ないこと

### 書いてたこと
* テストを書く真の目的は「バグ修正に必要な時間のコスト削減」
* テストの意図 
  * バグを見つける
  * 仕様書となる
  * 設計の決定を遅らせる
    * Input/Outputをテストすることで中身は後からリファクタが効く
  * 抽象を支える
* 何をテストするかを知る
  * 重複しないテストにする
    * 蛇足
      * オブジェクト指向は他のオブジェクトを意図的に無視することが設計の核心
  * 受信メッセージはその戻り値の状態をテストする
  * 送信コマンドメッセージは送られたことがテストされるべき
  * 送信クエリメッセージはテストされるべきではない
* いつテストするかを知る
  * テストを最小に書く意味があるならそうする
* テストの方法を知る
  * テストをするときアプリケーションのオブジェクトを大きくなる22つにカテゴリ分けできる
    1. 自身がテストするオブジェクト
    2. その他全て

### わからなかったところ
* 設計の決定を遅らせる
  * これはテストなのか？単純にコードの書き方なのでは？
* 抽象を支える？
  * I/Oがテストで保証されるだけやからあんまり関係なくね？
  * よく読んだが、結局抽象化するにはI/Oが大切でそれを保証するテストも大切よね？って感じか？
* 送信コマンドメッセージとは?
  * オブジェクトAからBに送るメッセージみたいなもの(A目線)
  * 受信メッセージはB目線でメッセージが送られてきたらどんなアウトプットがあるか的な感じか？

